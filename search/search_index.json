{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Quick JWT","text":"<p> Quick JWT library for authorization in FastAPI applications </p> <p> </p> <p>Source Code: https://github.com/maxim-f1/quick_jwt</p> <p>Documentation https://maxim-f1.github.io/quick_jwt/</p> <p>Quick JWT is a lightweight and convenient solution for handling JWT token-based authorization.</p> <p>The key features are:</p> <ul> <li> <p>Full integration with FastAPI framework and Intuitive use of FastAPI style features.</p> </li> <li> <p>Easy customization of environment variables via Pydantic-Settings and Middleware.</p> </li> <li> <p>Convenient functions for wrapping Depends with data type persistence.</p> </li> <li> <p>Many Depends functions for a large number of tasks.</p> </li> <li> <p>Ability to customize standard PyJWT driver to custom solutions.</p> </li> <li> <p>Support for function arguments for PyJWT driver, as well as Pydantic validation functions.</p> </li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<p>Quick JWT stands on the shoulders of giants:</p> <ul> <li> <p>FastAPI - main web framework.</p> </li> <li> <p>PyJWT - default JWT driver.</p> </li> <li> <p>Pydantic Settings - extension for pydantic with .env variables.</p> </li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Create and activate a virtual environment and then install Quick JWT:</p> <pre><code>$ pip install quick-jwt\n</code></pre>"},{"location":"#example","title":"Example","text":""},{"location":"#create-it","title":"Create it","text":"<p>Create a file <code>main.py</code> with:</p> <pre><code>from fastapi import FastAPI\nfrom pydantic import BaseModel\nfrom quick_jwt import (\n    QuickJWTConfig,\n    QuickJWTMiddleware,\n    create_jwt_depends,\n)\n\nkey = \"default_key\"\nquick_jwt_config = QuickJWTConfig(encode_key=key, decode_key=key)\n\napp = FastAPI()\napp.add_middleware(QuickJWTMiddleware, quick_jwt_config)\n\n\nclass UserScheme(BaseModel):\n    sub: str\n\n\n@app.get(\"/create-tokens\")\nasync def create_tokens(\n    sub: str, \n    jwt: create_jwt_depends(UserScheme, UserScheme)\n):\n    user = UserScheme(sub=sub)\n    tokens = await jwt.create_jwt_tokens(user, user)\n    return tokens\n</code></pre>"},{"location":"#run-it","title":"Run it","text":"<p>Run the server with:</p> <pre><code>$ fastapi dev main.py\n\n \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 FastAPI CLI - Development mode \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n \u2502                                                     \u2502\n \u2502  Serving at: http://127.0.0.1:8000                  \u2502\n \u2502                                                     \u2502\n \u2502  API docs: http://127.0.0.1:8000/docs               \u2502\n \u2502                                                     \u2502\n \u2502  Running in development mode, for production use:   \u2502\n \u2502                                                     \u2502\n \u2502  fastapi run                                        \u2502\n \u2502                                                     \u2502\n \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\nINFO:     Will watch for changes in these directories: ['/home/user/code/awesomeapp']\nINFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\nINFO:     Started reloader process [2248755] using WatchFiles\nINFO:     Started server process [2248757]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\n</code></pre>"},{"location":"#check-it","title":"Check it","text":"<p>Open your browser at http://127.0.0.1:8000/create-tokens?sub=some_id.</p> <p>You will see the JSON response as:</p> <pre><code>{\n  \"access\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJzb21lX2lkIn0.EerZU4uZCRh7yXxOqsZKTwzls7BnL-6C8jidTTkit6k\",\n  \"refresh\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJzb21lX2lkIn0.EerZU4uZCRh7yXxOqsZKTwzls7BnL-6C8jidTTkit6k\"\n}\n</code></pre>"},{"location":"#interactive-api-docs-upgrade","title":"Interactive API docs upgrade","text":"<p>Now go to http://127.0.0.1:8000/docs.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of the MIT license.</p>"},{"location":"install/","title":"Install","text":"<p>This guide provides instructions for installing the Quick JWT library, which enables JSON Web Token (JWT) authentication in your Python projects, using Python 3.12 or higher.</p> <p>Prerequisites</p> <p>Python 3.12 or higher installed</p>"},{"location":"install/#using-pip","title":"Using pip","text":"<p>Run the following command to install the <code>quick-jwt</code> library:</p> <pre><code>pip install quick-jwt\n</code></pre>"},{"location":"install/#using-poetry","title":"Using Poetry","text":"<p>Add the <code>quick-jwt</code> package to your project: <pre><code>poetry add quick-jwt\n</code></pre></p>"},{"location":"install/#using-uv","title":"Using uv","text":"<p>Install <code>quick-jwt</code> using uv: <pre><code>uv add quick-jwt\n</code></pre></p>"},{"location":"setup/","title":"Setup","text":"<p>To customize the library, you will need to do a few simple things.</p> <p>Prerequisites</p> <p>Make sure you have installed the library. How to do this was explained on the previous install page.</p>"},{"location":"setup/#setting-variables","title":"Setting variables","text":"<p>To work with Quick JWT, you will need to set up variables in the <code>QuickJWTConfig</code> configuration class.</p> <p>The simplest example of setting up <code>QuickJWTConfig</code> that will allow a full user of the library:</p> <pre><code>from quick_jwt import QuickJWTConfig\n\nkey = \"default_key\"\nconfig = QuickJWTConfig(encode_key=key, decode_key=key)\n</code></pre> <p>The encode_key and decode_key variables are the only mandatory arguments in the configuration class.</p> <p>Note</p> <p>The <code>key</code> variable will be responsible for encrypting and decrypting JWT tokens, as the example will use the <code>HS256</code> symmetric encryption algorithm.</p> <p>Environment variables</p> <p>This is only a tutorial example. Don't use hardcode in your project. It is better to use <code>.env</code> files with environment variables.  If the variables are already in the environment, this code will suffice: </p> <pre><code>from quick_jwt import QuickJWTConfig\n\nconfig = QuickJWTConfig()\n</code></pre> <p>This is possible thanks to the pydantic_settings library.</p>"},{"location":"setup/#middleware","title":"Middleware","text":"<p>In order for Quick JWT to know what variables you have defined for your project you must use <code>QuickJWTMiddleware</code>:</p> <pre><code>from fastapi import FastAPI\nfrom quick_jwt import (\n    QuickJWTConfig,\n    QuickJWTMiddleware,\n)\n\nkey = \"default_key\"\nconfig = QuickJWTConfig(encode_key=key, decode_key=key)\n\napp = FastAPI()\napp.add_middleware(QuickJWTMiddleware, config)\n</code></pre> <p>Now your project is ready to fully utilize the Quick JWT library</p>"},{"location":"setup/#advanced-settings","title":"Advanced settings","text":"<p>Inside the library there is a wide range of functionality for customizing its behavior. The following is a list of the most common ways to override the standard logic.</p>"},{"location":"setup/#pyjwt-options","title":"PyJWT options","text":"<p>There are cases when it is necessary to strictly specify which fields will be used in access and refresh tokens. You can override the driver for this purpose:</p> <pre><code>from jwt import PyJWT\nfrom quick_jwt import QuickJWTConfig\n\noptions = {\n    \"verify_signature\": True,\n    \"verify_exp\": True,\n    \"verify_nbf\": False,\n    \"verify_iat\": False,\n    \"verify_aud\": False,\n    \"verify_iss\": False,\n    \"verify_sub\": True,\n    \"verify_jti\": False,\n    \"require\": [],\n}\ndriver = PyJWT(\n    options=options\n)\nconfig = QuickJWTConfig(driver=driver)\n</code></pre>"},{"location":"setup/#cookie-parameters-for-access-and-refresh-tokens","title":"Cookie parameters for access and refresh tokens","text":"<pre><code>from datetime import timedelta\n\nfrom quick_jwt import QuickJWTConfig\n\nconfig = QuickJWTConfig(\n    access_token_name='access',\n    access_token_expires=timedelta(days=2),\n    access_token_path='/',\n    access_token_domain='domain.com',\n    access_token_secure=True,\n    access_token_httponly=True,\n    access_token_samesite='lax',\n)\n</code></pre> <p>Note</p> <p>You can override the refresh behavior of the token by the same principle.</p>"},{"location":"setup/#additional-variables-for-the-encode-function","title":"Additional variables for the encode function","text":"<p>When encrypting tokens, additional parameters can be thrown in:</p> <pre><code>import json\n\nfrom quick_jwt import QuickJWTConfig\n\nconfig = QuickJWTConfig(\n    encode_algorithm='HS256',\n    encode_headers={'X-Custom-Header': 'Value'},\n    encode_json_encoder=json.JSONEncoder,\n    encode_sort_headers=False,\n)\n</code></pre>"},{"location":"setup/#additional-variables-for-the-decode-function","title":"Additional variables for the decode function","text":"<pre><code>from quick_jwt import QuickJWTConfig\n\nconfig = QuickJWTConfig(\n    decode_algorithms=['HS256'],\n    decode_options={'sub': False},\n    decode_verify=False,\n)\n</code></pre>"},{"location":"setup/#custom-driver","title":"Custom driver","text":"<p>The default driver for the library is PyJWT, but you can also override it with the <code>driver</code> variable:</p> <pre><code>from quick_jwt import QuickJWTConfig\n\nconfig = QuickJWTConfig(driver=AnotherDriver())\n</code></pre> <p>Note</p> <p>For a custom driver to work correctly, it must have <code>encode</code> and <code>decode</code> functions.</p>"},{"location":"usage/check_jwt/","title":"Check JWT","text":"<p>Prerequisites</p> <p>The creation of JWT tokens will require install and setup library. </p>"},{"location":"usage/check_jwt/#depends-job-description","title":"Depends job description","text":"<p>Interaction with the library functionality is done through a special <code>Depends</code> function that allows you to save the type of data being transferred and perform payload validation of tokens.</p>"},{"location":"usage/check_jwt/#examples","title":"Examples","text":""},{"location":"usage/check_jwt/#access-token","title":"Access token","text":"<p>To check the access token you need to use the function <code>check_jwt_depends</code></p> <pre><code>from pydantic import BaseModel\nfrom quick_jwt import (\n    access_check_depends\n)\n\nclass UserScheme(BaseModel):\n    sub: str\n\n\n@app.get(\"/access-token-check\")\nasync def access_token_check(\n        user: access_check_depends(UserScheme)\n) -&gt; UserScheme:\n    return user\n</code></pre> <p>What happened?</p> <p>The <code>access_check_depends</code> function was passed a scheme into which the <code>access</code> token payload will be converted. Also, a field for sending the token via headers or cookies appeared in the endpoint.</p>"},{"location":"usage/check_jwt/#refresh-token","title":"Refresh token","text":"<p>In addition to checking the access token, you can also check the refresh token:</p> <pre><code>from pydantic import BaseModel\nfrom quick_jwt import (\n    refresh_check_depends\n)\n\nclass UserScheme(BaseModel):\n    sub: str\n\n\n@app.get(\"/refresh-token-check\")\nasync def refresh_token_check(\n        user: refresh_check_depends(UserScheme)\n) -&gt; UserScheme:\n    return user\n</code></pre> <p>What happened?</p> <p>The <code>refresh_check_depends</code> function was passed a scheme into which the <code>refresh</code> token payload will be converted. Also, a field for sending the token via headers or cookies appeared in the endpoint.</p>"},{"location":"usage/check_jwt_optional/","title":"Check JWT optional","text":"<p>Prerequisites</p> <p>The creation of JWT tokens will require install and setup library. </p>"},{"location":"usage/check_jwt_optional/#depends-job-description","title":"Depends job description","text":"<p>Interaction with the library functionality is done through a special <code>Depends</code> function that allows you to save the type of data being transferred and perform payload validation of tokens.</p> <p>In addition to the standard token checks described in Check JWT, there are depends that perform an optional token check.</p> <p>That is, if the token was not found or is invalid, the function will return None instead of the token payload.</p>"},{"location":"usage/check_jwt_optional/#examples","title":"Examples","text":""},{"location":"usage/check_jwt_optional/#access-token","title":"Access token","text":"<p>To check the access token you need to use the function <code>check_jwt_depends</code></p> <pre><code>from pydantic import BaseModel\nfrom quick_jwt import (\n    access_check_optional_depends\n)\n\nclass UserScheme(BaseModel):\n    sub: str\n\n\n@app.get(\"/access-token-check-optional\")\nasync def access_token_check_optional(\n        user: access_check_optional_depends(UserScheme)\n) -&gt; UserScheme | None:\n    return user\n</code></pre> <p>What happened?</p> <p>The <code>access_token_check_optional</code> function was passed a scheme into which the <code>access</code> token payload will be converted. Also, a field for sending the token via headers or cookies appeared in the endpoint.</p>"},{"location":"usage/check_jwt_optional/#refresh-token","title":"Refresh token","text":"<p>In addition to checking the access token, you can also check the refresh token:</p> <pre><code>from pydantic import BaseModel\nfrom quick_jwt import (\n    refresh_check_optional_depends\n)\n\nclass UserScheme(BaseModel):\n    sub: str\n\n\n@app.get(\"/refresh-token-check-optional\")\nasync def refresh_token_check_optional(\n        user: refresh_check_optional_depends(UserScheme)\n) -&gt; UserScheme | None:\n    return user\n</code></pre> <p>What happened?</p> <p>The <code>refresh_check_optional_depends</code> function was passed a scheme into which the <code>refresh</code> token payload will be converted. Also, a field for sending the token via headers or cookies appeared in the endpoint.</p>"},{"location":"usage/create_jwt/","title":"Create JWT","text":"<p>Prerequisites</p> <p>The creation of JWT tokens will require install and setup library. </p>"},{"location":"usage/create_jwt/#depends-job-description","title":"Depends job description","text":"<p>Interaction with the library functionality is done through a special <code>Depends</code> function that allows you to save the type of data being transferred and perform payload validation of tokens.</p>"},{"location":"usage/create_jwt/#examples","title":"Examples","text":""},{"location":"usage/create_jwt/#basic-use-case","title":"Basic use case","text":"<p>To create tokens, you need to add an annotation to the endpoint:</p> <pre><code>from pydantic import BaseModel\nfrom quick_jwt import (\n    JWTTokensDTO,\n    create_jwt_depends\n)\n\nclass UserScheme(BaseModel):\n    sub: str\n\n\n@app.get(\"/create-tokens\")\nasync def create_tokens(\n        sub: str,\n        jwt: create_jwt_depends(\n            access_payload=UserScheme, \n            refresh_payload=UserScheme\n        )\n) -&gt; JWTTokensDTO:\n    user = UserScheme(sub=sub)\n    tokens = await jwt.create_jwt_tokens(\n        access_payload=user, \n        refresh_payload=user\n    )\n    return tokens\n</code></pre> <p>What happened?</p> <p>An instance class that has a <code>create_jwt_tokens</code> function to generate tokens was written to the <code>jwt</code> variable. The <code>payload</code> schemas for <code>access</code> and <code>refresh</code> tokens were passed into the parameters of the <code>create_jwt_depends</code> function. The <code>create_jwt_tokens</code> function parameters were passed to the <code>create_jwt_tokens</code> function to be converted into payloads and packaged into JWT tokens.</p> <p>Note</p> <p>In our case, the patterns for <code>access</code> and <code>refresh</code> tokens are the same to simplify the examples. You can use different patterns.</p> <p>A pair of tokens will be returned in response to this request:</p> Response<pre><code>{\n  \"access\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJzb21lX2lkIn0.EerZU4uZCRh7yXxOqsZKTwzls7BnL-6C8jidTTkit6k\",\n  \"refresh\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJzb21lX2lkIn0.EerZU4uZCRh7yXxOqsZKTwzls7BnL-6C8jidTTkit6k\"\n}\n</code></pre>"},{"location":"usage/create_jwt/#generating-access-token","title":"Generating access token","text":"<p>If you only need to create <code>access</code> or <code>refresh</code> you can call the <code>create_access_token</code> or <code>create_refresh_token</code> function respectively.</p> <pre><code>from pydantic import BaseModel\nfrom quick_jwt import create_jwt_depends\n\nclass UserScheme(BaseModel):\n    sub: str\n\n\n@app.get(\"/create-access-token\")\nasync def create_access_token(\n        sub: str,\n        jwt: create_jwt_depends(\n            access_payload=UserScheme, \n            refresh_payload=UserScheme\n        )\n) -&gt; str:\n    user = UserScheme(sub=sub)\n    token = await jwt.create_access_token(\n        access_payload=user\n    )\n    return token\n</code></pre> <p>Note</p> <p>The function generated an <code>access</code> token that can be used in further checks.</p> Response<pre><code>\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJzb21lX2lkIn0.EerZU4uZCRh7yXxOqsZKTwzls7BnL-6C8jidTTkit6k\"\n</code></pre>"},{"location":"usage/create_jwt/#generating-refresh-token","title":"Generating refresh token","text":"<pre><code>from pydantic import BaseModel\nfrom quick_jwt import create_jwt_depends\n\nclass UserScheme(BaseModel):\n    sub: str\n\n\n@app.get(\"/create-refresh-token\")\nasync def create_refresh_token(\n        sub: str,\n        jwt: create_jwt_depends(\n            access_payload=UserScheme, \n            refresh_payload=UserScheme\n        )\n) -&gt; str:\n    user = UserScheme(sub=sub)\n    token = await jwt.create_refresh_token(\n        refresh_payload=user\n    )\n    return token\n</code></pre> <p>Note</p> <p>The function generated a <code>refresh</code> token that can be used in further checks.</p> Response<pre><code>\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJzb21lX2lkIn0.EerZU4uZCRh7yXxOqsZKTwzls7BnL-6C8jidTTkit6k\"\n</code></pre>"},{"location":"usage/logout_jwt/","title":"Logout JWT","text":"<p>Prerequisites</p> <p>The creation of JWT tokens will require install and setup library. </p>"},{"location":"usage/logout_jwt/#depends-job-description","title":"Depends job description","text":"<p>Interaction with the library functionality is done through a special <code>Depends</code> function that allows you to save the type of data being transferred and perform payload validation of tokens.</p> <p>To log out of your account, you will need to pass access or refresh tokens to cookies, after which they will be deleted.</p>"},{"location":"usage/logout_jwt/#examples","title":"Examples","text":"<pre><code>from quick_jwt import logout_depends\n\n@app.get('/logout-depends')\nasync def logout_depends_endpoint(logout: logout_depends()):\n    return\n</code></pre>"},{"location":"usage/refresh_jwt/","title":"Refresh JWT","text":"<p>Prerequisites</p> <p>The creation of JWT tokens will require install and setup library. </p>"},{"location":"usage/refresh_jwt/#depends-job-description","title":"Depends job description","text":"<p>Interaction with the library functionality is done through a special <code>Depends</code> function that allows you to save the type of data being transferred and perform payload validation of tokens.</p> <p>To update the token, the user must pass the refresh token into the request via headers or cookies.</p> <p>After checking the token, a pair of new JWT tokens will be created.</p>"},{"location":"usage/refresh_jwt/#examples","title":"Examples","text":""},{"location":"usage/refresh_jwt/#base-example","title":"Base example","text":"<pre><code>from pydantic import BaseModel\nfrom quick_jwt import (\n    refresh_jwt_depends\n)\n\nclass UserScheme(BaseModel):\n    sub: str\n\n\n@app.get('/refresh-jwt')\nasync def refresh_jwt_depends_endpoint(\n    refresh_jwt: refresh_jwt_depends(UserScheme, UserScheme),\n):\n    access_token = await refresh_jwt.create_access_token(refresh_jwt.payload)\n    refresh_token = await refresh_jwt.create_refresh_token(refresh_jwt.payload)\n    return {'access': access_token, 'refresh': refresh_token}\n</code></pre> <p>What happened?</p> <p>At the start of the <code>refresh_jwt_depends</code> function, the token was checked. If it was valid for the user, a pair of JWT tokens is created</p>"}]}